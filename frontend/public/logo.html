<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NexaSphere Logo Animation</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #ffffff;
        }

        canvas {
            display: block;
        }

        #container {
            width: 100%;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
    </style>
</head>

<body>
    <div id="container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        let scene, camera, renderer, sphereGroup, flareMesh;
        let clock = new THREE.Clock();

        function init() {
            // 1. Setup Scene, Camera, Renderer
            scene = new THREE.Scene();
            // Set background to solid white as requested
            scene.background = new THREE.Color(0xffffff);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 25;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('container').appendChild(renderer.domElement);

            // 2. Create the Geometry representing the network
            // An Icosahedron with detail 1 closely matches the reference image structure
            const radius = 10;
            const detail = 1;
            const baseGeometry = new THREE.IcosahedronGeometry(radius, detail);

            // We need two things: The lines connecting vertices, and dots at the vertices.
            sphereGroup = new THREE.Group();

            // --- A. The Lines (Edges) ---
            // WireframeGeometry converts the shape into just its edges
            const lineGeometry = new THREE.WireframeGeometry(baseGeometry);

            // Create gradient colors for the lines based on position
            const lineColors = [];
            const posAttribute = lineGeometry.getAttribute('position');
            const colorCyan = new THREE.Color(0x00e5ff); // Bright Cyan
            const colorPurple = new THREE.Color(0x6a0dad); // Deep Purple

            for (let i = 0; i < posAttribute.count; i++) {
                const x = posAttribute.getX(i);
                const y = posAttribute.getY(i);
                const z = posAttribute.getZ(i);

                // Calculate a "mix factor" based on position.
                // Top-Left-Front should be cyan, Bottom-Right-Back should be purple.
                // We normalize coordinates roughly between 0 and 1.
                let mixFactor = ((x / radius) + (y / radius) + (z / radius) + 3) / 6;
                // Invert mix because we want top-left to be the start color
                mixFactor = 1 - Math.max(0, Math.min(1, mixFactor));

                const finalColor = colorPurple.clone().lerp(colorCyan, mixFactor);
                lineColors.push(finalColor.r, finalColor.g, finalColor.b);
            }
            lineGeometry.setAttribute('color', new THREE.Float32BufferAttribute(lineColors, 3));

            const lineMaterial = new THREE.LineBasicMaterial({
                vertexColors: true, // Tell material to use the colors we just calculated
                linewidth: 1.5,
                opacity: 0.8,
                transparent: true
            });
            const linesMesh = new THREE.LineSegments(lineGeometry, lineMaterial);
            sphereGroup.add(linesMesh);


            // --- B. The Nodes (Dots) ---
            // We use PointsMaterial on the original vertices
            const pointsMaterial = new THREE.PointsMaterial({
                size: 0.8,
                vertexColors: true // Use the same gradient logic
            });
            // Re-applying color logic to the base geometry vertices for the points
            const pointColors = [];
            const basePosAttribute = baseGeometry.getAttribute('position');
            for (let i = 0; i < basePosAttribute.count; i++) {
                const x = basePosAttribute.getX(i);
                const y = basePosAttribute.getY(i);
                const z = basePosAttribute.getZ(i);
                let mixFactor = ((x / radius) + (y / radius) + (z / radius) + 3) / 6;
                mixFactor = 1 - Math.max(0, Math.min(1, mixFactor));
                const finalColor = colorPurple.clone().lerp(colorCyan, mixFactor);
                pointColors.push(finalColor.r, finalColor.g, finalColor.b);
            }
            baseGeometry.setAttribute('color', new THREE.Float32BufferAttribute(pointColors, 3));

            const pointsMesh = new THREE.Points(baseGeometry, pointsMaterial);
            sphereGroup.add(pointsMesh);


            // --- C. The "Flare" (The bright spot) ---
            // Create a glowing sphere for the bright spot on the left
            const flareGeo = new THREE.SphereGeometry(1.2, 16, 16);
            const flareMat = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.9
            });
            flareMesh = new THREE.Mesh(flareGeo, flareMat);

            // Position it roughly on a vertex to the left side
            flareMesh.position.set(-radius * 0.8, radius * 0.2, radius * 0.3);

            // Add a point light there to make it feel like it emits light
            const flareLight = new THREE.PointLight(0x00e5ff, 2, 20);
            flareLight.position.copy(flareMesh.position);
            sphereGroup.add(flareLight);
            sphereGroup.add(flareMesh);

            // Add the whole group to the scene
            scene.add(sphereGroup);

            // Basic ambient light so purple areas aren't pure black
            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);

            // Handle window resizing
            window.addEventListener('resize', onWindowResize, false);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            const elapsed = clock.getElapsedTime();

            // 1. Rotate the whole sphere slowly
            sphereGroup.rotation.y = elapsed * 0.2; // Horizontal rotation
            sphereGroup.rotation.x = Math.sin(elapsed * 0.1) * 0.2; // Slight vertical tilt

            // 2. Pulse the flare
            const pulseScale = 1 + Math.sin(elapsed * 3) * 0.2;
            flareMesh.scale.set(pulseScale, pulseScale, pulseScale);
            flareMesh.material.opacity = 0.7 + Math.sin(elapsed * 3) * 0.3;

            renderer.render(scene, camera);
        }

        init();
        animate();
    </script>
</body>

</html>